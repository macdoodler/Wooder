'use client';

import React, { useState, useEffect } from "react";
import { 
  fetchCalculations, 
  createCalculation, 
  updateCalculation, 
  deleteCalculation,
  deleteAllCalculations
} from "./lib/api";
import { 
  SavedCalculation, 
  Stock, 
  Part, 
  FreeSpace, 
  Placement, 
  StockUsage, 
  Results 
} from "./lib/types";

export default function Home() {
  const [planName, setPlanName] = useState("");
  const [description, setDescription] = useState("");
  const [kerfThickness, setKerfThickness] = useState(0);
  const [availableStocks, setAvailableStocks] = useState<Stock[]>([]);
  const [requiredParts, setRequiredParts] = useState<Part[]>([]);
  const [results, setResults] = useState<Results | null>(null);
  const [savedCalculations, setSavedCalculations] = useState<SavedCalculation[]>([]);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [currentCalcId, setCurrentCalcId] = useState<string | null>(null);
  const [isEditing, setIsEditing] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  
  // Load saved calculations from database on component mount
  useEffect(() => {
    async function loadCalculations() {
      setIsLoading(true);
      try {
        const calculations = await fetchCalculations();
        setSavedCalculations(calculations);
      } catch (error) {
        console.error("Error loading saved calculations:", error);
      } finally {
        setIsLoading(false);
      }
    }
    
    loadCalculations();
  }, []);

  // Reset form to create a new calculation
  const resetForm = () => {
    setPlanName("");
    setDescription("");
    setKerfThickness(0);
    setAvailableStocks([]);
    setRequiredParts([]);
    setResults(null);
    setCurrentCalcId(null);
    setIsEditing(false);
    setErrorMessage(null);
  };

  const addStock = () => {
    setAvailableStocks([
      ...availableStocks,
      { length: 0, width: 0, quantity: 1 },
    ]);
  };

  const updateStock = (index: number, field: keyof Stock, value: number) => {
    const updatedStocks = [...availableStocks];
    updatedStocks[index][field] = value;
    setAvailableStocks(updatedStocks);
  };

  const deleteStock = (index: number): void => {
    setAvailableStocks(availableStocks.filter((_, i) => i !== index));
  };

  const addPart = () => {
    setRequiredParts([
      ...requiredParts,
      { length: 0, width: 0, quantity: 1 },
    ]);
  };

  const updatePart = (index: number, field: keyof Part, value: number) => {
    const updatedParts = [...requiredParts];
    updatedParts[index][field] = value;
    setRequiredParts(updatedParts);
  };

  const deletePart = (index: number): void => {
    setRequiredParts(requiredParts.filter((_, i) => i !== index));
  };

  const validateInputs = (): boolean => {
    // Reset error message
    setErrorMessage(null);

    // Check if plan has a name
    if (!planName.trim()) {
      setErrorMessage("Please provide a name for the calculation");
      return false;
    }

    // Check if we have stocks and parts defined
    if (availableStocks.length === 0) {
      setErrorMessage("Please add at least one stock sheet");
      return false;
    }

    if (requiredParts.length === 0) {
      setErrorMessage("Please add at least one required part");
      return false;
    }

    // Check if all values are valid numbers
    for (const stock of availableStocks) {
      if (stock.length <= 0 || stock.width <= 0 || stock.quantity <= 0) {
        setErrorMessage("All stock dimensions and quantities must be positive numbers");
        return false;
      }
    }

    for (const part of requiredParts) {
      if (part.length <= 0 || part.width <= 0 || part.quantity <= 0) {
        setErrorMessage("All part dimensions and quantities must be positive numbers");
        return false;
      }
    }

    // Check if parts can fit in any stock
    for (const part of requiredParts) {
      const canFit = availableStocks.some(stock => 
        (part.length <= stock.length && part.width <= stock.width) || 
        (part.width <= stock.length && part.length <= stock.width)
      );
      
      if (!canFit) {
        setErrorMessage(`Part (${part.length}x${part.width}) is too large to fit in any available stock`);
        return false;
      }
    }
    
    return true;
  };

  // Helper function to find best matching space for a part
  const findBestSpace = (
    part: Part, 
    freeSpaces: FreeSpace[], 
    strategy: 'best-fit' | 'first-fit' = 'best-fit'
  ): { spaceIndex: number; rotated: boolean } | null => {
    if (strategy === 'first-fit') {
      // First-fit strategy (faster but less optimal)
      for (let i = 0; i < freeSpaces.length; i++) {
        const space = freeSpaces[i];
        
        // Try without rotation
        if (part.length + kerfThickness <= space.width && part.width + kerfThickness <= space.height) {
          return { spaceIndex: i, rotated: false };
        }
        
        // Try with rotation
        if (part.width + kerfThickness <= space.width && part.length + kerfThickness <= space.height) {
          return { spaceIndex: i, rotated: true };
        }
      }
    } else {
      // Best-fit strategy (more optimal but slower)
      let bestFit = { spaceIndex: -1, rotated: false, waste: Infinity };
      
      for (let i = 0; i < freeSpaces.length; i++) {
        const space = freeSpaces[i];
        
        // Try without rotation
        if (part.length + kerfThickness <= space.width && part.width + kerfThickness <= space.height) {
          const widthWaste = space.width - (part.length + kerfThickness);
          const heightWaste = space.height - (part.width + kerfThickness);
          const waste = widthWaste * heightWaste;
          
          if (waste < bestFit.waste) {
            bestFit = { spaceIndex: i, rotated: false, waste };
          }
        }
        
        // Try with rotation
        if (part.width + kerfThickness <= space.width && part.length + kerfThickness <= space.height) {
          const widthWaste = space.width - (part.width + kerfThickness);
          const heightWaste = space.height - (part.length + kerfThickness);
          const waste = widthWaste * heightWaste;
          
          if (waste < bestFit.waste) {
            bestFit = { spaceIndex: i, rotated: true, waste };
          }
        }
      }
      
      if (bestFit.spaceIndex !== -1) {
        return { spaceIndex: bestFit.spaceIndex, rotated: bestFit.rotated };
      }
    }
    
    return null; // No suitable space found
  };

  // Helper function to check if two rectangles overlap
  const rectanglesOverlap = (
    rect1: {x: number, y: number, width: number, height: number},
    rect2: {x: number, y: number, width: number, height: number}
  ): boolean => {
    // Check if one rectangle is to the left of the other
    if (rect1.x + rect1.width <= rect2.x || rect2.x + rect2.width <= rect1.x) {
      return false;
    }
    
    // Check if one rectangle is above the other
    if (rect1.y + rect1.height <= rect2.y || rect2.y + rect2.height <= rect1.y) {
      return false;
    }
    
    // If neither of the above is true, the rectangles overlap
    return true;
  };

  // Helper function to subtract a rectangle from another and return resulting free spaces
  const subtractRectangle = (
    original: FreeSpace,
    subtracted: {x: number, y: number, width: number, height: number}
  ): FreeSpace[] => {
    // If they don't overlap, return the original space
    if (!rectanglesOverlap(original, subtracted)) {
      return [original];
    }
    
    const result: FreeSpace[] = [];
    
    // Check if there's space to the right of the subtracted rectangle
    if (original.x + original.width > subtracted.x + subtracted.width) {
      result.push({
        x: subtracted.x + subtracted.width,
        y: original.y,
        width: (original.x + original.width) - (subtracted.x + subtracted.width),
        height: original.height
      });
    }
    
    // Check if there's space to the left of the subtracted rectangle
    if (subtracted.x > original.x) {
      result.push({
        x: original.x,
        y: original.y,
        width: subtracted.x - original.x,
        height: original.height
      });
    }
    
    // Check if there's space above the subtracted rectangle
    if (subtracted.y > original.y) {
      result.push({
        x: original.x,
        y: original.y,
        width: original.width,
        height: subtracted.y - original.y
      });
    }
    
    // Check if there's space below the subtracted rectangle
    if (original.y + original.height > subtracted.y + subtracted.height) {
      result.push({
        x: original.x,
        y: subtracted.y + subtracted.height,
        width: original.width,
        height: (original.y + original.height) - (subtracted.y + subtracted.height)
      });
    }
    
    // Filter out any spaces that are too small or have invalid dimensions
    return result.filter(space => space.width > 0 && space.height > 0);
  };

  // Helper function to split free space after placing a part
  const splitFreeSpace = (
    space: FreeSpace,
    partWidth: number,
    partHeight: number,
    partX: number,
    partY: number
  ): FreeSpace[] => {
    const result: FreeSpace[] = [];
    
    // Adjust part dimensions to include kerf
    const adjustedWidth = partWidth + kerfThickness;
    const adjustedHeight = partHeight + kerfThickness;
    
    // Right space
    if (space.x + space.width > partX + adjustedWidth) {
      result.push({
        x: partX + adjustedWidth,
        y: space.y,
        width: (space.x + space.width) - (partX + adjustedWidth),
        height: space.height
      });
    }
    
    // Bottom space
    if (space.y + space.height > partY + adjustedHeight) {
      result.push({
        x: space.x,
        y: partY + adjustedHeight,
        width: space.width,
        height: (space.y + space.height) - (partY + adjustedHeight)
      });
    }
    
    return result;
  };

  // Calculate optimal cuts
  const calculateOptimalCuts = () => {
    if (!validateInputs()) {
      return;
    }
    
    setIsLoading(true);
    setErrorMessage(null);
    
    try {
      // Create working copies of our data
      const partsToPlace: { 
        partIndex: number; 
        part: Part; 
        remainingQuantity: number; 
      }[] = [];
      
      // Expand parts based on quantity
      requiredParts.forEach((part, index) => {
        partsToPlace.push({
          partIndex: index,
          part,
          remainingQuantity: part.quantity
        });
      });
      
      // Sort parts from largest to smallest (by area)
      partsToPlace.sort((a, b) => 
        (b.part.length * b.part.width) - (a.part.length * a.part.width)
      );
      
      // Create a copy of the sorted parts for the results
      const sortedParts = partsToPlace.map(p => p.part);
      
      // Create a copy of available stocks for our algorithm to use
      const remainingStocks = availableStocks.map((stock, index) => ({
        ...stock,
        stockIndex: index // Keep track of the original index for reference
      }));
      
      // Initialize results
      const stockUsage: StockUsage[] = [];
      let totalUsedSheets = 0;
      
      // Place parts one by one
      for (const { partIndex, part, remainingQuantity: initialQuantity } of partsToPlace) {
        let remainingQuantity = initialQuantity;
        
        while (remainingQuantity > 0) {
          let placed = false;
          
          // Try to place on existing sheets first
          for (const usage of stockUsage) {
            // Get updated list of free spaces for this sheet
            const freeSpaces = usage.freeSpaces;
            
            // Find best space for this part
            const bestSpace = findBestSpace(part, freeSpaces, 'best-fit');
            
            if (bestSpace) {
              const { spaceIndex, rotated } = bestSpace;
              const space = freeSpaces[spaceIndex];
              
              // Add placement
              usage.placements.push({
                partId: `Part-${partIndex}`,
                x: space.x,
                y: space.y,
                rotated
              });
              
              // Update used area
              usage.usedArea += part.length * part.width;
              
              // Split the free space
              const newSpaces = splitFreeSpace(
                space,
                rotated ? part.width : part.length,
                rotated ? part.length : part.width,
                space.x,
                space.y
              );
              
              // Replace the used space with new spaces
              freeSpaces.splice(spaceIndex, 1, ...newSpaces);
              
              // Process all remaining free spaces to ensure no overlaps with the newly placed part
              const placedPartRect = {
                x: space.x,
                y: space.y,
                width: rotated ? part.width + kerfThickness : part.length + kerfThickness,
                height: rotated ? part.length + kerfThickness : part.width + kerfThickness
              };
              
              // Check each free space (except the ones we just added) for potential overlap
              for (let i = 0; i < freeSpaces.length; i++) {
                // Skip the newly added spaces
                if (i >= spaceIndex && i < spaceIndex + newSpaces.length) continue;
                
                const currentSpace = freeSpaces[i];
                
                // Check if this space overlaps with our placed part
                if (rectanglesOverlap(currentSpace, placedPartRect)) {
                  // Split this space to avoid the overlap
                  const adjustedSpaces = subtractRectangle(currentSpace, placedPartRect);
                  
                  // Replace the current space with the adjusted spaces
                  freeSpaces.splice(i, 1, ...adjustedSpaces);
                  
                  // Adjust the index since we're modifying the array during iteration
                  i += adjustedSpaces.length - 1;
                }
              }
              
              placed = true;
              remainingQuantity--;
              break;
            }
          }
          
          // If not placed, allocate a new sheet
          if (!placed) {
            // Find first available stock with quantity > 0
            const availableStockIndex = remainingStocks.findIndex(s => s.quantity > 0);
            
            if (availableStockIndex >= 0) {
              const stockToUse = remainingStocks[availableStockIndex];
              stockToUse.quantity--; // Decrement available quantity
              totalUsedSheets++;
              
              const newSheetId = `Sheet-${stockUsage.length + 1}`;
              const stockIndex = stockToUse.stockIndex;
              const stock = availableStocks[stockIndex];
              
              // Initialize free spaces for the new sheet
              const freeSpaces: FreeSpace[] = [{
                x: 0, 
                y: 0, 
                width: stock.length, 
                height: stock.width
              }];
              
              // Find best space for this part on the new sheet
              const bestSpace = findBestSpace(part, freeSpaces, 'best-fit');
              
              if (bestSpace) {
                const { spaceIndex, rotated } = bestSpace;
                const space = freeSpaces[spaceIndex];
                
                // Create new usage for this sheet
                const newUsage: StockUsage = {
                  sheetId: newSheetId,
                  stockIndex,
                  placements: [{
                    partId: `Part-${partIndex}`,
                    x: space.x,
                    y: space.y,
                    rotated
                  }],
                  usedArea: part.length * part.width,
                  wasteArea: 0,
                  freeSpaces: [] // Will be updated below
                };
                
                // Split the free space
                const newSpaces = splitFreeSpace(
                  space,
                  rotated ? part.width : part.length,
                  rotated ? part.length : part.width,
                  space.x,
                  space.y
                );
                
                // Update free spaces
                newUsage.freeSpaces = newSpaces;
                
                stockUsage.push(newUsage);
                remainingQuantity--;
              } else {
                // This should never happen as we validated sizes earlier
                console.error(`Part ${partIndex} can't fit on a new sheet`);
                break;
              }
            } else {
              // No more stock available
              setErrorMessage(`Not enough stock to fit all parts. Still need ${remainingQuantity} of Part-${partIndex}`);
              break;
            }
          }
        }
      }
      
      // Calculate waste area for each sheet
      let totalWaste = 0;
      for (const usage of stockUsage) {
        const stockIndex = usage.stockIndex;
        const stock = availableStocks[stockIndex];
        const totalArea = stock.length * stock.width;
        usage.wasteArea = totalArea - usage.usedArea;
        totalWaste += usage.wasteArea;
      }
      
      // Store the results with the sorted parts used for calculation
      setResults({
        success: true,
        message: errorMessage || "Cuts calculated successfully.",
        stockUsage,
        totalWaste,
        totalUsedSheets,
        sortedParts // Save the sorted parts used during calculation
      });
    } catch (error) {
      console.error("Error calculating cuts:", error);
      setErrorMessage("An error occurred during calculation");
    } finally {
      setIsLoading(false);
    }
  };

  // Save or update a calculation
  const saveCalculation = async () => {
    if (!validateInputs()) {
      return;
    }

    setIsLoading(true);
    
    try {
      const timestamp = Date.now();
      
      // Create the calculation object
      const calculation: SavedCalculation = {
        id: currentCalcId || `calc-${timestamp}`,
        name: planName,
        description,
        kerfThickness,
        availableStocks,
        requiredParts,
        results,
        dateCreated: isEditing ? savedCalculations.find(c => c.id === currentCalcId)?.dateCreated || timestamp : timestamp,
        dateModified: timestamp
      };

      // Check if we're updating an existing calculation
      if (isEditing && currentCalcId) {
        const success = await updateCalculation(calculation);
        if (success) {
          // Update local state
          const updatedCalculations = savedCalculations.map(calc => 
            calc.id === currentCalcId ? calculation : calc
          );
          setSavedCalculations(updatedCalculations);
          alert("Calculation updated successfully");
        } else {
          alert("Failed to update calculation");
        }
      } else {
        // Otherwise, it's a new calculation
        const success = await createCalculation(calculation);
        if (success) {
          setSavedCalculations([...savedCalculations, calculation]);
          setCurrentCalcId(calculation.id);
          setIsEditing(true);
          alert("Calculation saved successfully");
        } else {
          alert("Failed to save calculation");
        }
      }
    } catch (error) {
      console.error("Error saving calculation:", error);
      alert("An error occurred while saving");
    } finally {
      setIsLoading(false);
    }
  };

  // Create a duplicate with a new name
  const duplicateCalculation = async () => {
    if (!validateInputs()) {
      return;
    }

    setIsLoading(true);
    
    try {
      // Generate a new ID and timestamp
      const timestamp = Date.now();
      const newId = `calc-${timestamp}`;
      
      // Create a copy with a modified name
      const duplicatedCalculation: SavedCalculation = {
        id: newId,
        name: `${planName} (Copy)`,
        description,
        kerfThickness,
        availableStocks,
        requiredParts,
        results,
        dateCreated: timestamp,
        dateModified: timestamp
      };

      const success = await createCalculation(duplicatedCalculation);
      
      if (success) {
        setSavedCalculations([...savedCalculations, duplicatedCalculation]);
        
        // Switch to the new calculation
        setPlanName(duplicatedCalculation.name);
        setCurrentCalcId(newId);
        setIsEditing(true);
        
        alert("Calculation duplicated successfully");
      } else {
        alert("Failed to duplicate calculation");
      }
    } catch (error) {
      console.error("Error duplicating calculation:", error);
      alert("An error occurred while duplicating");
    } finally {
      setIsLoading(false);
    }
  };

  // Load a calculation
  const loadCalculation = (id: string) => {
    const calculation = savedCalculations.find(calc => calc.id === id);
    if (!calculation) {
      alert("Calculation not found");
      return;
    }

    setPlanName(calculation.name);
    setDescription(calculation.description);
    setKerfThickness(calculation.kerfThickness);
    setAvailableStocks(calculation.availableStocks);
    setRequiredParts(calculation.requiredParts);
    setResults(calculation.results);
    setCurrentCalcId(calculation.id);
    setIsEditing(true);
    setErrorMessage(null);
  };

  // Delete a saved calculation
  const deleteSavedCalculation = async (id: string) => {
    // Ask for confirmation before deleting
    if (!confirm("Are you sure you want to delete this calculation?")) {
      return;
    }
    
    setIsLoading(true);
    
    try {
      const success = await deleteCalculation(id);
      
      if (success) {
        setSavedCalculations(savedCalculations.filter(calc => calc.id !== id));
        
        // If the deleted calculation was being edited, reset the form
        if (currentCalcId === id) {
          resetForm();
        }
      } else {
        alert("Failed to delete calculation");
      }
    } catch (error) {
      console.error("Error deleting calculation:", error);
      alert("An error occurred while deleting");
    } finally {
      setIsLoading(false);
    }
  };

  // Delete all saved calculations
  const deleteAllSavedCalculations = async () => {
    // Ask for confirmation before deleting all
    if (!confirm("Are you sure you want to delete ALL saved calculations? This cannot be undone.")) {
      return;
    }
    
    setIsLoading(true);
    
    try {
      const success = await deleteAllCalculations();
      
      if (success) {
        setSavedCalculations([]);
        resetForm();
      } else {
        alert("Failed to delete all calculations");
      }
    } catch (error) {
      console.error("Error deleting all calculations:", error);
      alert("An error occurred while deleting all calculations");
    } finally {
      setIsLoading(false);
    }
  };

  // Render UI
  return (
    <main className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-4">Wooder - Wood Cutting Optimizer</h1>
      
      {/* Display loading spinner */}
      {isLoading && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-white p-4 rounded-lg shadow-lg">
            <p className="text-lg">Processing...</p>
          </div>
        </div>
      )}
      
      {/* Error message display */}
      {errorMessage && (
        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4">
          <p>{errorMessage}</p>
        </div>
      )}
      
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="space-y-4">
          <div className="bg-white p-4 rounded shadow">
            <h2 className="text-xl font-bold mb-2">Calculation Settings</h2>
            
            <div className="mb-4">
              <label className="block text-sm font-medium mb-1">Plan Name</label>
              <input
                type="text"
                value={planName}
                onChange={(e) => setPlanName(e.target.value)}
                className="w-full px-3 py-2 border rounded"
              />
            </div>
            
            <div className="mb-4">
              <label className="block text-sm font-medium mb-1">Description (Optional)</label>
              <textarea
                value={description}
                onChange={(e) => setDescription(e.target.value)}
                className="w-full px-3 py-2 border rounded"
                rows={2}
              />
            </div>
            
            <div className="mb-4">
              <label className="block text-sm font-medium mb-1">Kerf Thickness (mm)</label>
              <input
                type="number"
                value={kerfThickness}
                onChange={(e) => setKerfThickness(parseFloat(e.target.value) || 0)}
                className="w-full px-3 py-2 border rounded"
                step="0.1"
                min="0"
              />
            </div>
          </div>
          
          <div className="bg-white p-4 rounded shadow">
            <h2 className="text-xl font-bold mb-2">Available Stock Sheets</h2>
            
            {availableStocks.map((stock, index) => (
              <div key={index} className="mb-2 p-2 border rounded bg-gray-50 flex items-center">
                <div className="flex-grow grid grid-cols-3 gap-2">
                  <div>
                    <label className="block text-xs">Length (mm)</label>
                    <input
                      type="number"
                      value={stock.length}
                      onChange={(e) => updateStock(index, "length", parseFloat(e.target.value) || 0)}
                      className="w-full px-2 py-1 border rounded"
                      min="0"
                    />
                  </div>
                  <div>
                    <label className="block text-xs">Width (mm)</label>
                    <input
                      type="number"
                      value={stock.width}
                      onChange={(e) => updateStock(index, "width", parseFloat(e.target.value) || 0)}
                      className="w-full px-2 py-1 border rounded"
                      min="0"
                    />
                  </div>
                  <div>
                    <label className="block text-xs">Quantity</label>
                    <input
                      type="number"
                      value={stock.quantity}
                      onChange={(e) => updateStock(index, "quantity", parseInt(e.target.value) || 0)}
                      className="w-full px-2 py-1 border rounded"
                      min="1"
                    />
                  </div>
                </div>
                <button
                  onClick={() => deleteStock(index)}
                  className="ml-2 px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600"
                >
                  ✕
                </button>
              </div>
            ))}
            
            <button
              onClick={addStock}
              className="w-full mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Add Stock
            </button>
          </div>
          
          <div className="bg-white p-4 rounded shadow">
            <h2 className="text-xl font-bold mb-2">Required Parts</h2>
            
            {requiredParts.map((part, index) => (
              <div key={index} className="mb-2 p-2 border rounded bg-gray-50 flex items-center">
                <div className="flex-grow grid grid-cols-3 gap-2">
                  <div>
                    <label className="block text-xs">Length (mm)</label>
                    <input
                      type="number"
                      value={part.length}
                      onChange={(e) => updatePart(index, "length", parseFloat(e.target.value) || 0)}
                      className="w-full px-2 py-1 border rounded"
                      min="0"
                    />
                  </div>
                  <div>
                    <label className="block text-xs">Width (mm)</label>
                    <input
                      type="number"
                      value={part.width}
                      onChange={(e) => updatePart(index, "width", parseFloat(e.target.value) || 0)}
                      className="w-full px-2 py-1 border rounded"
                      min="0"
                    />
                  </div>
                  <div>
                    <label className="block text-xs">Quantity</label>
                    <input
                      type="number"
                      value={part.quantity}
                      onChange={(e) => updatePart(index, "quantity", parseInt(e.target.value) || 0)}
                      className="w-full px-2 py-1 border rounded"
                      min="1"
                    />
                  </div>
                </div>
                <button
                  onClick={() => deletePart(index)}
                  className="ml-2 px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600"
                >
                  ✕
                </button>
              </div>
            ))}
            
            <button
              onClick={addPart}
              className="w-full mt-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
            >
              Add Part
            </button>
          </div>
          
          <div className="flex flex-wrap gap-2">
            <button
              onClick={calculateOptimalCuts}
              className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600"
              disabled={isLoading}
            >
              Calculate Cuts
            </button>
            
            <button
              onClick={saveCalculation}
              className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
              disabled={isLoading}
            >
              {isEditing ? "Update" : "Save"} Calculation
            </button>
            
            {isEditing && (
              <button
                onClick={duplicateCalculation}
                className="px-4 py-2 bg-purple-500 text-white rounded hover:bg-purple-600"
                disabled={isLoading}
              >
                Duplicate
              </button>
            )}
            
            <button
              onClick={resetForm}
              className="px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600"
              disabled={isLoading}
            >
              New Calculation
            </button>
          </div>
        </div>
        
        <div className="space-y-4">
          {/* Results display */}
          {results && (
            <div className="bg-white p-4 rounded shadow">
              <h2 className="text-xl font-bold mb-2">Cutting Results</h2>
              
              <div className="mb-4">
                <p><strong>Total Sheets Used:</strong> {results.totalUsedSheets}</p>
                <p><strong>Total Waste Area:</strong> {results.totalWaste.toFixed(2)} mm²</p>
              </div>
              
              <div className="space-y-4">
                {results.stockUsage.map((usage, sheetIndex) => (
                  <div key={sheetIndex} className="border rounded p-2">
                    <h3 className="font-bold">
                      Sheet {sheetIndex + 1}: {usage.sheetId}
                    </h3>
                    <p>
                      Stock Size: {availableStocks[usage.stockIndex].length} × {availableStocks[usage.stockIndex].width} mm
                    </p>
                    <p>Waste: {usage.wasteArea.toFixed(2)} mm² ({((usage.wasteArea / (availableStocks[usage.stockIndex].length * availableStocks[usage.stockIndex].width)) * 100).toFixed(2)}%)</p>
                    
                    <div className="mt-2 relative border" style={{ 
                      width: '100%', 
                      height: '200px',
                      backgroundColor: '#f0f0f0'
                    }}>
                      {/* Scale factor to fit the visualization */}
                      {(() => {
                        const stockSize = availableStocks[usage.stockIndex];
                        const maxDim = Math.max(stockSize.length, stockSize.width);
                        const scale = 200 / maxDim;
                        
                        return usage.placements.map((placement, placementIndex) => {
                          const part = results.sortedParts[parseInt(placement.partId.split('-')[1])];
                          const width = placement.rotated ? part.width : part.length;
                          const height = placement.rotated ? part.length : part.width;
                          
                          return (
                            <div 
                              key={placementIndex}
                              style={{
                                position: 'absolute',
                                left: placement.x * scale,
                                top: placement.y * scale,
                                width: width * scale,
                                height: height * scale,
                                backgroundColor: `hsl(${(placementIndex * 137) % 360}, 70%, 60%)`,
                                border: '1px solid #333',
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'center',
                                fontSize: '10px'
                              }}
                              title={`Part ${placement.partId}: ${width}×${height}mm at (${placement.x},${placement.y})`}
                            >
                              {placement.partId}
                            </div>
                          );
                        });
                      })()}
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}
          
          {/* Saved Calculations */}
          <div className="bg-white p-4 rounded shadow">
            <div className="flex justify-between mb-2">
              <h2 className="text-xl font-bold">Saved Calculations</h2>
              
              {savedCalculations.length > 0 && (
                <button
                  onClick={deleteAllSavedCalculations}
                  className="px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm"
                >
                  Delete All
                </button>
              )}
            </div>
            
            {savedCalculations.length === 0 ? (
              <p className="text-gray-500 italic">No saved calculations yet.</p>
            ) : (
              <div className="space-y-2">
                {savedCalculations
                  .sort((a, b) => b.dateModified - a.dateModified)
                  .map((calc) => (
                    <div key={calc.id} className="p-2 border rounded hover:bg-gray-50 flex justify-between">
                      <div className="flex-grow">
                        <h3 className="font-bold">{calc.name}</h3>
                        <p className="text-sm text-gray-600">
                          {calc.description || "No description"}
                        </p>
                        <p className="text-xs text-gray-500">
                          Last modified: {new Date(calc.dateModified).toLocaleString()}
                        </p>
                      </div>
                      <div className="flex items-center">
                        <button
                          onClick={() => loadCalculation(calc.id)}
                          className="px-2 py-1 bg-blue-500 text-white rounded hover:bg-blue-600 text-sm mr-2"
                        >
                          Load
                        </button>
                        <button
                          onClick={() => deleteSavedCalculation(calc.id)}
                          className="px-2 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm"
                        >
                          Delete
                        </button>
                      </div>
                    </div>
                  ))}
              </div>
            )}
          </div>
        </div>
      </div>
    </main>
  );
}
